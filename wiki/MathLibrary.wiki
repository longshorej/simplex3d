#summary Overview, Examples and Comparison to GLSL
#labels Featured

= General =

The library mimics GLSL so it is easy to use. The downside is slow performance which will be remedied with a compiler plugin. Given the possibilities of optimization with the plugin, it is possible to have a very easy to use library that run faster than anything written in pure Java.

Additional benefit of mimicking GLSL is that you can recycle your GLSL skills using a familiar set of constructs and functions. If you are new to GLSL then using simplex3d mathlib should make it easier for you to use GLSL in the future.

-----

= Getting started =

Download simplex3dMath.jar and add it to your classpath. In your scala file, use the following imports:

{{{
import simplex3d.math._ //all the vectors and matrix classes
import simplex3d.math.VecMath._ //all GLSL functions
import simplex3d.math.ExtendedMath._ //all extra functions
}}}

Examples:

{{{
import simplex3d.math._ //all the vectors and matrix classes

//Factories
var u = Vec2(1)
var v = Vec4(1, 2, 3, 4)
v = Vec4(u, 5, 6)

val m = Mat4x3(1)
val n = Mat4(v, v, v, v)

//Accessors
v.x = 10
v.z = u.x

m(0) = v
m(0, 3) = 4

//Swizzling
val a = v.xyz
val b = v.wxz
val c = v.rgb
val d = v.stpq

v.xz = Vec2(0)
v.ra = v.wy

//Arithmetic operations on vectors
val s = v.xyz + Vec3(1, 2, 3)
s *= 10
val t = 0.5f*(s + v)

//Matrix multiplication
val m = Mat4(2)
val n = Mat4x3(col0, col1, col2)
val t = m*n //t: Mat4x3

//Extended random, capable of generating random float, int and boolean vectors
val random = Random()
def vec2 = random.nextVec2()*100
def mat2 = Mat2(vec2, vec2)
println(mat2*vec2)


import simplex3d.math.VecMath._ //all GLSL functions

// Basic operations on vectors
val len = length(v)
val dist = distance(u, v)
val d = dot(u, v)
val normal = normalize(v)

// Component-wise operations on vectors
val inrads = radians(v)
val indegrees = degrees(inrads)
val allsin = sin(v)
val angles = asin(allsin)
var res = sinh(v)
res = asinh(v)
val p = pow(u, v) //p.x = u.x^v.x; p.y = u.y^v.y
val allexp = exp(v)
val back = log(allexp)
res = exp2(v)
res = log2(v)
val root = sqrt(v)
val invroot = inversesqrt(v) // 1/sqrt
val allabs = abs(v)
val signs = sign(v)
res = floor(v)
res = trunc(v)
res = round(v)
res = ceil(v)
res = fract(v)
val allmin = min(u, v)
val c = clamp(v, minVal, maxVal)

//Noise functions backed by simplex noise implementation
val n1 = noise1(v) //n1: Float
val n2 = noise2(v) //n2: Vec2
val n3 = noise3(v) //n3: Vec3
val n4 = noise4(v) //n4: Vec4


import simplex3d.math.ExtendedMath._ //all extra functions

//`approxEqual` to compare floating point numbers, vectors and matrices
if (approxEqual(u, v, 0.0001f)) println("approx")

//Quaternions and angle/axis rotations
val q1 = quatFrom(radians(30), Vec3.UnitX)
val q2 = quatFrom(radians(45), Vec3.UnitY)
val q = q2*q1 // first rotaty by q1 then by q2
val v = q*Vec3(1, 1, 1) //rotate Vec3(1, 1, 1) by q

val r1 = rotationMatFrom(q)
val r2 = rotationMatFrom(radians(180), normalize(Vec3(1, 1, 1))

val result = Vec3(0)
val angle1 = angleAxisFrom(r1, result); val axis1 = Vec3(result)
val angle2 = angleAxisFrom(q2, result); val axis2 = Vec3(result)

//`lerp` for matrices and `slerp` for quaternions
val interpolatedMat = lerp(m0, m1, 0.4f)
val q3 = slerp(q1, q2, 0.8f)

//Projection matrices for setting 3d camera
val camPerspective = perspective(fieldOfView, aspectRatio, near, far)
val camOrtho = ortho(left, right, bottom, top, near, far)

//2x3 and 3x4 matrices as transformations
val tf = Mat3x4(1)
val position = tf.transofrmPoint(v)
val orientation = tf.transofrmVector(u)

//Flexible way to build transformations
// Template: Transform(translation, rotation, scale)
// Template: Transform(translation, rotation)
// Template: Transform(rotation, scale)
// InverseTransform avoids matrix inverse, same templates as Transform
val model = Transform(Vec3(0, 1, 0), radians(60), Vec3.UnitY, 2) //model: Mat3x4
val view = InverseTransform(cam.translation, cam.rotation, cam.scale) //view: Mat3x4
val modelView = view*model // modelView: Mat3x4

val complicated = Translation(u)*Scale(s1)*Rotation(q1)*Scale(s2)*Translation(v)
// first p is translated by v, then scaled by s2, then rotated by q1,
// then scaled by s1 and finally translated by u
val p = complicated.transformPoint(p)

//Matrix inverse
val inv = inverse(tf)
}}}

Most of the GLSL features are supported. See the following sections for differences, missing features and extras.

-----

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are a couple of small quirks you should be aware of.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || _notation is unsupported until Scala 2.8_ ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
val u = ConstVec3(1, 2, 3)
u.x = 10 //compile time error

var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4
v -= Vec4(0.5f) //works, because v is var

val w: ConstVec2 = 3*(u.xy + v.zw) //implicit conversion from Vec2 to ConstVec2
}}}

== Matrix as multidimensional array ==

Due to the language constrains, writing into matrix using array notation is different. This will be fixed with a compiler plugin. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Matrix constructors ==

Matrix constructors accept any mix of floats and vectors, just like in GLSL. If the total number of floats extracted from arguments does not add up to the matrix size, you get an error. With GLSL you get a compile time error. However with current mathlib implementation you will get a runtime error instead. This will be fixed with the compiler plugin.
Example:
{{{
val w = Mat3(1, 2, Vec2(3, 4), Vec4(5, 6, 7, 8), 9) //works
val c = Mat2(1, new Object(), 2, 3) //compile time error
val m = Mat2x3(Vec4(1), Vec4(2), Vec4(3)) //runtime error - too many floats in arguments
val f = Mat4(1, 2, 3, 4) //runtime error - too few floats in arguments
}}}

== Modf ==
`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

-----

= Extras =

There are some extras not present in GLSL or in Scala.

== Cast ==

Scala has a rather nasty way of casting with `asInstanceOf[Type]`. To make things more readable and stay within the spirit of GLSL it is recommended to use these casts:
  * int(x: Long)
  * int(x: Float)
  * int(x: Double)
  * long(x: Float)
  * long(x: Double)
  * float(x: Double)

Examples:
{{{
val a = float(java.lang.Math.PI) //this is just an example, there is a constant Pi defined in VecMath
val b = int(sin(Pi/2)*100)
}}}

== Other additions ==

Some other additions are:
  * `:=` operator, equivalent to set(), but does not require parentheses
  * `lengthSquare` method if you want to avoid using square root
  * `approxEqual` to compare floating point numbers, vectors and matrices
  * Extended random, capable of generating random float, int and boolean vectors
  * Quaternions and angle/axis rotations
  * `lerp` for matrices and `slerp` for quaternions
  * Projection matrices
  * 2x3 and 3x4 matrices as transformations
  * Flexible way to build transformations
  * Matrix inverse
-----

= Planned =
The following features are planned but not yet implemented:
  * Support for double vectors and matrices
  * Compiler plugin!

= Feedback =

Any feedback regarding code correctness and optimization is welcomed. However keep in mind that the aim of the library is to stay as close to GLSL as possible, things that are astray from this path are unlikely to be implemented.