#summary Overview, Examples and Comparison to GLSL
#labels Featured

= General =

The library mimics GLSL so it is easy to use. Additional benefit of being close GLSL is that you can recycle your GLSL skills using a familiar set of constructs and functions. If you are new to GLSL then using simplex3d mathlib should make it easier for you to use GLSL in the future.

-----

= Getting started =

Download simplex3dMath.jar and add it to your classpath. In your scala file, use the following imports:
{{{
// for boolean vectors
import simplex3d.math._ // boolean vectors and some base classes
import simplex3d.math.BaseMath._ // casting and some boolean operations

// boolean examples
val b2 = Vec2b(true, true)
val b3 = Vec3b(true, true, false)
val nb = not(b3)

// for int vectors
import simplex3d.math.intm._ // all the int vectors

// int examples
val i2 = Vec2i(1, 2)
val i3 = Vec3i(1, 2, 3)
val max = IntMath.max(i2, i3.yz) // use fully qualified names for int functions

// for float vectors and matrices
import simplex3d.math.floatm._ // all the float vectors and matrices
import simplex3d.math.floatm.FloatMath._ // all the float math functions

// float examples
val f2 = Vec2f(1.5f, 2.5f)
val f3 = Vec3f(1.5f, 2.5f, 3)
val mf = Mat4f(1)

// for double vectors and matrices
import simplex3d.math.doublem._ // all the double vectors and matrices
import simplex3d.math.doublem.DoubleMath._ // all the double math functions

// double examples
val d2 = Vec2d(1.5, 2.5)
val d3 = Vec3d(1.5, 2.5, 3)
val md4 = Mat4d(1)
}}}

Alternative imports allow you to use Double or Float vectors and matrices without
appending "f" or "d" at the end of the type. This is useful when you choose Float
or Double type as your default floating-point type.

Float as default floating-point type:
{{{
// alternative import, using short names for Float data types
import simplex3d.math.floatm.renamed._

// float examples
val v2: Vec2 = Vec2(1, 2) // the type of v2 is Vec2f
val v3 = Vec3(1, 2, 3) // the type of v3 is Vec3f
val m = Mat3(1) // the type of m is Mat3f
}}}

Double as default floating-point type:
{{{
// alternative import, using short names for Double data types
import simplex3d.math.doublem.renamed._

// double examples
val v2: Vec2 = Vec2(1, 2) // the type of v2 is Vec2d
val v3 = Vec3(1, 2, 3) // the type of v3 is Vec3d
val m = Mat3(1) // the type of m is Mat3d
}}}

-----

= Using the library =

The following is a list of examples on how to use the API:
{{{
import simplex3d.math.floatm.renamed._ //using short names for Float data types
import simplex3d.math.floatm.FloatMath._ //using all float functions

//Factories
var u = Vec2(1)
var v = Vec4(1, 2, 3, 4)
v = Vec4(u, 5, 6)

val m = Mat4x3(1)
val n = Mat4(v, v, v, v)

//Accessors
v.x = 10
v.z = u.x

m(0) = v
m(0, 3) = 4

//Swizzling
val a = v.xyz
val b = v.wxz
val c = v.rb

v.xz = Vec2(0)
v.ra = v.wy

//Arithmetic operations on vectors
val s = v.xyz + Vec3(1, 2, 3)
s *= 10
val t = 0.5f*(s + v)

//Matrix multiplication
val m = Mat4(2)
val n = Mat4x3(col0, col1, col2)
val t = m*n //t: Mat4x3

// Basic operations on vectors
val len = length(v)
val dist = distance(u, v)
val d = dot(u, v)
val normal = normalize(v)

// Component-wise operations on vectors
val inrads = radians(v)
val indegrees = degrees(inrads)
val allsin = sin(v)
val angles = asin(allsin)
var res = sinh(v)
res = asinh(v)
val p = pow(u, v) //p.x = u.x^v.x; p.y = u.y^v.y
val allexp = exp(v)
val back = log(allexp)
res = exp2(v)
res = log2(v)
val root = sqrt(v)
val invroot = inversesqrt(v) // 1/sqrt
val allabs = abs(v)
val signs = sign(v)
res = floor(v)
res = trunc(v)
res = round(v)
res = ceil(v)
res = fract(v)
val allmin = min(u, v)
val c = clamp(v, minVal, maxVal)

//Noise functions backed by simplex noise implementation
val n1 = noise1(v) //n1: Float
val n2 = noise2(v) //n2: Vec2
val n3 = noise3(v) //n3: Vec3
val n4 = noise4(v) //n4: Vec4

//`approxEqual` to compare floating point numbers, vectors and matrices
if (approxEqual(u, v, 0.0001f)) println("approx")

//Quaternions and angle/axis rotations
val q1 = quatFrom(radians(30), Vec3.UnitX)
val q2 = quatFrom(radians(45), Vec3.UnitY)
val q = q2*q1 // first rotaty by q1 then by q2
val v = q*Vec3(1, 1, 1) //rotate Vec3(1, 1, 1) by q

val r1 = rotationMatFrom(q)
val r2 = rotationMatFrom(radians(180), normalize(Vec3(1, 1, 1))

val result = Vec3(0)
val angle1 = angleAxisFrom(r1, result); val axis1 = Vec3(result)
val angle2 = angleAxisFrom(q2, result); val axis2 = Vec3(result)

//`lerp` for matrices and `slerp` for quaternions
val interpolatedMat = lerp(m0, m1, 0.4f)
val q3 = slerp(q1, q2, 0.8f)

//Projection matrices for setting 3d camera
val camPerspective = perspective(fieldOfView, aspectRatio, near, far)
val camOrtho = ortho(left, right, bottom, top, near, far)

//2x3 and 3x4 matrices as transformations
val tf = Mat3x4(1)
val position = tf.transofrmPoint(v)
val orientation = tf.transofrmVector(u)

//Flexible way to build transformations
// Template: Transform(translation, rotation, scale)
// Template: Transform(translation, rotation)
// Template: Transform(rotation, scale)
// InverseTransform avoids matrix inverse, same templates as Transform
val model = Transform(Vec3(0, 1, 0), radians(60), Vec3.UnitY, 2) //model: Mat3x4
val view = InverseTransform(cam.translation, cam.rotation, cam.scale) //view: Mat3x4
val modelView = view*model // modelView: Mat3x4

val complicated = Translation(u)*Scale(s1)*Rotation(q1)*Scale(s2)*Translation(v)
// first p is translated by v, then scaled by s2, then rotated by q1,
// then scaled by s1 and finally translated by u
val p = complicated.transformPoint(point)

//Matrix inverse
val inv = inverse(transformationMatrix)
}}}

If you import "simplex3d.math.floatm" package then you have to append "f" to the name of each data type:
{{{
import simplex3d.math.floatm._ // using full names for Float data types

var u = Vec2f(1)
var v = Vec4f(1, 2, 3, 4)
v = Vec4f(u, 5, 6)

val m = Mat4x3f(1)
val n = Mat4f(v, v, v, v)
}}}

Similarly, if you import "import simplex3d.math.doublem" package then you have to append "d" to the name of each data type:
{{{
import simplex3d.math.doublem._ // using full names for Double data types

var u = Vec2d(1)
var v = Vec4d(1, 2, 3, 4)
v = Vec4d(u, 5, 6)

val m = Mat4x3d(1)
val n = Mat4d(v, v, v, v)
}}}

You can choose default floating point type and still use the other type by specifying full name. In the following example the default type is Float, yet you can still use Double by specifying the full type name (with "d" appended):
{{{
import simplex3d.math.floatm.renamed._ // using short names for Float data types
import simplex3d.math.doublem._ // using full names for Double data types

val m = Mat4(1) // the type of m is Mat4f
val n = Mat3d(1) // the type of n is Mat3d
}}}

Most of the GLSL features are supported. See the following sections for differences, missing features and extras.

-----

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are a couple of small quirks.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || Mat2x2 ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Swizzling ==
xyzw and rgba swilling modes are supported for integer and floating point vectors.

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
//defining a constant using declared type
var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4

//defining constant using a factory
val u = ConstVec3(1, 2, 3)
}}}

Using constants:
{{{
var mutable: Vec3 = Vec3(1)
var constant = ConstVec3(2, 2, 2)

//implicit conversion from const to mutable
mutable = constant
//copy without reassigning
mutable := constant

//implicit conversion from mutable to const
constant = mutable

val finalConstant = ConstVec3(1, 1, 1)
finalConstant = mutable //compile time error, since val cannot be reassigned
}}}

When writing functions, you can support both constant and mutable types without implicit conversions. To accomplish this, use the common supertype AnyVec:
{{{
//This function will trigger an implicit conversion if v is ConstVec3.
def foo(v: Vec3) = 2*v

//This function will accept both ConstVec3 and Vec3 without implicit conversions
def foo(v: AnyVec3) = 2*v

//Similar for matrices:
def bar(m: AnyMat3) :Mat3 = m*Mat3(2)
}}}

== Matrix as multidimensional array ==

Due to the language constrains, writing into matrix using array notation is different from GLSL. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Matrix constructors ==

Unlike GLSL, matrix constructors do not accept an arbitrary mix of floats and vectors. You can specify all the values or all the columns to construct a matrix.
Example:
{{{
val s = Mat4(2) // a 4x4 matrix with 2 on diagonal
val m = Mat2(1, 2, 3, 4)
val n = Mat3(Vec3.UnitX, Vec3.UnitY, Vec3.UnitZ)
}}}

== Modf ==
`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

== Casting Vectors ==
Casting vectors is similar to casting primitives, if a primitive can be automatically converted, so can the vector. For example:
{{{
val v = Vec3f(1)
val u = Vec3i(2)
v = u // integer vector u is promoted to the float vector
}}}

In cases when the primitive type cannot be promoted, you have to use a manual cast:
{{{
val v = Vec3f(1)
val u = Vec3d(2)
v = u // compile time error, since double cannot be promoted to float
v = Vec3f(u) // works
}}}

== Casting Matrices ==
You can cast matrices of different size, just like in GLSL:
{{{
val m = Mat4(1)
val n = Mat2x3(m)
}}}
You cannot cast float matrices to doubles or vice versa. Use vector or primitive accessors as arguments in the corresponding constructor:
{{{
// using primitive accessors
val a = Mat2f(1)
val b = Mat2d(a.m00, a.m01, a.m10, a.m11)

// using vector accessors
val m = Mat3d(1)
val n = Mat3f(m(0), m(1), m(2))
}}}

-----

= Extras =

There are some extras not present in GLSL or in Scala.

== Casting ==

Scala has a rather nasty way of casting with `asInstanceOf[Type]`. To make things more readable it is recommended to use these casts:
  * byte(x)
  * short(x)
  * int(x)
  * long(x)
  * float(x)
  * double(x)

Examples:
{{{
val a = float(java.lang.Math.PI) //this is just an example, there is a constant Pi defined in VecMath
val b = int(sin(Pi/2)*100)
}}}

== Other additions ==

Some other additions are:
  * `:=` operator, equivalent to set(), but does not require parentheses
  * `lengthSquare` method if you want to avoid using square root
  * `approxEqual` to compare floating point numbers, vectors and matrices
  * functions to generate random float, int and boolean vectors
  * Quaternions and angle/axis rotations
  * `lerp` for matrices and `slerp` for quaternions
  * Projection matrices for camera
  * 2x3 and 3x4 matrices as transformations
  * Flexible way to build transformations
  * Matrix inverse
-----

= Compiler plugin =
Initially there was a plan to make a compiler plugin. However after evaluating new JVM switch -XX:+DoEscapeAnalysis the compiler plugin was cancelled.<br/>
Escape analysis seems to eliminate temporary new objects in the critical sections of the code, giving results that are very close to the results with temporary variable management the compiler plugin was supposed to do.<br/>
JVM can optimise code at a lower level and managing temporary valiriables manually or via compiler plugin can interfere with that process causing the code to perform slower in some cases.<br/>
Additionally, JVM will continue to improve as it always does. So even if the compiler plugin is capable of giving marginally better results now, that will not always be the case.

= Feedback =

Any feedback regarding code correctness and optimization is welcomed. However keep in mind that the aim of the library is to stay as close to GLSL as possible, things that are astray from this path are unlikely to be implemented.