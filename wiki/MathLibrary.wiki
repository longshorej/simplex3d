#summary Overview, Examples and Comparison to GLSL
#labels Featured

= General =

The library mimics GLSL so it is easy to use. The downside is slow performance which will be remedied with a compiler plugin. Given the possibilities of optimization with the plugin, it is possible to have a very easy to use library that run faster than anything written in pure Java.

Additional benefit of mimicking GLSL is that you can recycle your GLSL skills using a familiar set of constructs and functions. If you are new to GLSL then using simplex3d mathlib should make it easier for you to use GLSL in the future.

-----

= Getting started =

Download simplex3dMath.jar and add it to your classpath. In your scala file, use the following imports:

{{{
import simplex3d.math._ //all the vectors and matrix classes
import simplex3d.math.VecMath._ //all the functions
import simplex3d.math.ExtendedMath._ //color conversion
}}}

Examples:

{{{
//Factories
var u = Vec2(1)
var v = Vec4(1, 2, 3, 4)
v = Vec4(u, 5, 6)

val m = Mat4x3(1)
val n = Mat4(v, v, v, v)

//Accessors
v.x = 10
v.z = u.x

m(0) = v
m(0, 3) = 4

//Swizzling
val a = v.xyz
val b = v.wxz
val c = v.rgb
val d = v.stpq

v.xz = Vec2(0)
v.ra = v.wy

//Arithmetic operations on vectors
val s = v.xyz + Vec3(1, 2, 3)
s *= 10
val t = 0.5f*(s + v)

//Matrix multiplication
//All of the GLSL mathematical functions that have valid signatures in Scala
//Mutable and immutable vector and matrix types
//Noise functions backed by simplex noise implementation
}}}

Most of the GLSL features are supported. See the following sections for differences, missing features and extras.

-----

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are a couple of small quirks you should be aware of.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || _notation is unsupported until Scala 2.8_ ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
val u = ConstVec3(1, 2, 3)
u.x = 10 //compile time error

var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4
v -= Vec4(0.5f) //works, because v is var

val w: ConstVec2 = 3*(u.xy + v.zw) //implicit conversion from Vec2 to ConstVec2
}}}

== Matrix as multidimensional array ==

Due to the language constrains, writing into matrix using array notation is different. This will be fixed with a compiler plugin. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Matrix constructors ==

Matrix constructors accept any mix of floats and vectors, just like in GLSL. If the total number of floats extracted from arguments does not add up to the matrix size, you get an error. With GLSL you get a compile time error. However with current mathlib implementation you will get a runtime error instead. This will be fixed with the compiler plugin.
Example:
{{{
val w = Mat3(1, 2, Vec2(3, 4), Vec4(5, 6, 7, 8), 9) //works
val c = Mat2(1, new Object(), 2, 3) //compile time error
val m = Mat2x3(Vec4(1), Vec4(2), Vec4(3)) //runtime error - too many floats in arguments
val f = Mat4(1, 2, 3, 4) //runtime error - too few floats in arguments
}}}

== Modf ==
`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

-----

= Extras =

There are some extras not present in GLSL or in Scala.

== Cast ==

Scala has a rather nasty way of casting with `asInstanceOf[Type]`. To make things more readable and stay within the spirit of GLSL it is recommended to use these casts:
  * int(x: Long)
  * int(x: Float)
  * int(x: Double)
  * long(x: Float)
  * long(x: Double)
  * float(x: Double)

Examples:
{{{
val a = float(java.lang.Math.PI) //this is just an example, there is a constant Pi defined in VecMath
val b = int(sin(Pi/2)*100)
}}}

== Debugging ==

A method `isValid` is added to every type. A vector (or a matrix) is considered to be valid if none of it's fields are NaN or Inf.

== Approximation ==

Due to a floating point arithmetics, the values are not always exact. To help compare computed vectors to the predefined ones an approximate comparision operator was introduced. To test for approximate equality, the difference between values is compared to VecMath.ApproximationDelta = 0.00001f. This value should be suitable for most cases but it may not always work, so you may have to inline your own approximation code.
{{{
val u = Vec4(1)
val v = Vec4(1.000001)
println(u ~= v) //prints true
v := Vec4(1.0001) // := operator sets the values rather than reassigning the reference
println(u ~= v) //prints false
println(u !~ v) //prints true
}}}

== Transformation matrix ==

Using matrix multiplication for vector transformation in GLSL is not suitable for general purpose library. This is because you have to use a 4x4 matrix and extend your vec3 to vec4 by setting w to 0, then multiple and cast back to vec3. Example:
{{{
// Cumbersome transform
val tranformMatrix = Mat4(1)
val have = Vec3(10)
val need = Vec4(have, 0)
val tranformed = (transformMatrix*need).xyz
}}}

As noted, this procedure is rather cumbersome. So to make it easier to use matrices that store translation as a last column to transform vectors, a transform() method was introduced.
{{{
// Simple transform
val tranformMatrix = Mat3x4(1)
val have = Vec3(10)
val tranformed = transformMatrix.transform(have)
}}}

== Other additions ==

Some other additions are:
  * Color conversion from Vec3i, Vec3, Vec4i and Vec4 to rgb, rgba, argb, bgr, abgr, bgra
  * `:=` operator, equivalent to set(), but does not require parentheses
  * `lengthSquare` method if you want to avoid using square root
  * Extended random, capable of generating random float, int and boolean vectors

-----

= Planned =
The following features are planned but not yet implemented:
  * Quaternions
  * Various methods to compute rotation
  * Support for double vectors and matrices
  * Compiler plugin!

_The development of the compiler plugin will not start until Scala 2.8 release due to compiler architecture changes._

= Feedback =

Any feedback regarding code correctness and optimization is welcomed. However keep in mind that the aim of the library is to stay as close to GLSL as possible, things that are astray from this path are unlikely to be implemented.