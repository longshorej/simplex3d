#summary Overview, Examples and Comparison to GLSL
#labels Featured

= General =

The library mimics GLSL so it is easy to use. The downside is slow performance which will be remedied with a compiler plugin. Given the possibilities of optimization with the plugin, it is possible to have a very easy to use library that run faster than anything written in pure Java.

Additional benefit of mimicking GLSL is that you can recycle your GLSL skills using a familiar set of constructs and functions. If you are new to GLSL then using simplex3d mathlib should make it easier for you to use GLSL in the future.

-----

= Getting started =

Download simplex3dMath.jar and add it to your classpath. In your scala file, use the following imports:

{{{
import simplex3d.math._ //all the vectors and matrix classes
import simplex3d.math.VecMath._ //all GLSL functions
import simplex3d.math.ExtendedMath._ //all extra functions
}}}

Examples:

{{{
//Factories
var u = Vec2(1)
var v = Vec4(1, 2, 3, 4)
v = Vec4(u, 5, 6)

val m = Mat4x3(1)
val n = Mat4(v, v, v, v)

//Accessors
v.x = 10
v.z = u.x

m(0) = v
m(0, 3) = 4

//Swizzling
val a = v.xyz
val b = v.wxz
val c = v.rgb
val d = v.stpq

v.xz = Vec2(0)
v.ra = v.wy

//Arithmetic operations on vectors
val s = v.xyz + Vec3(1, 2, 3)
s *= 10
val t = 0.5f*(s + v)

//Matrix multiplication
//All of the GLSL mathematical functions that have valid signatures in Scala
//Mutable and immutable vector and matrix types
//Noise functions backed by simplex noise implementation

//`approxEqual` to compare floating point numbers, vectors and matrices
//Extended random, capable of generating random float, int and boolean vectors
//Quaternions and angle/axis rotations
//`lerp` for matrices and `slerp` for quaternions
//Projection matrices
//2x3 and 3x4 matrices as transformations
//Flexible way to build transformations
//Matrix inverse
}}}

Most of the GLSL features are supported. See the following sections for differences, missing features and extras.

-----

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are a couple of small quirks you should be aware of.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || _notation is unsupported until Scala 2.8_ ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
val u = ConstVec3(1, 2, 3)
u.x = 10 //compile time error

var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4
v -= Vec4(0.5f) //works, because v is var

val w: ConstVec2 = 3*(u.xy + v.zw) //implicit conversion from Vec2 to ConstVec2
}}}

== Matrix as multidimensional array ==

Due to the language constrains, writing into matrix using array notation is different. This will be fixed with a compiler plugin. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Matrix constructors ==

Matrix constructors accept any mix of floats and vectors, just like in GLSL. If the total number of floats extracted from arguments does not add up to the matrix size, you get an error. With GLSL you get a compile time error. However with current mathlib implementation you will get a runtime error instead. This will be fixed with the compiler plugin.
Example:
{{{
val w = Mat3(1, 2, Vec2(3, 4), Vec4(5, 6, 7, 8), 9) //works
val c = Mat2(1, new Object(), 2, 3) //compile time error
val m = Mat2x3(Vec4(1), Vec4(2), Vec4(3)) //runtime error - too many floats in arguments
val f = Mat4(1, 2, 3, 4) //runtime error - too few floats in arguments
}}}

== Modf ==
`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

-----

= Extras =

There are some extras not present in GLSL or in Scala.

== Cast ==

Scala has a rather nasty way of casting with `asInstanceOf[Type]`. To make things more readable and stay within the spirit of GLSL it is recommended to use these casts:
  * int(x: Long)
  * int(x: Float)
  * int(x: Double)
  * long(x: Float)
  * long(x: Double)
  * float(x: Double)

Examples:
{{{
val a = float(java.lang.Math.PI) //this is just an example, there is a constant Pi defined in VecMath
val b = int(sin(Pi/2)*100)
}}}

== Other additions ==

Some other additions are:
  * `:=` operator, equivalent to set(), but does not require parentheses
  * `lengthSquare` method if you want to avoid using square root
  * `approxEqual` to compare floating point numbers, vectors and matrices
  * Extended random, capable of generating random float, int and boolean vectors
  * Quaternions and angle/axis rotations
  * `lerp` for matrices and `slerp` for quaternions
  * Projection matrices
  * 2x3 and 3x4 matrices as transformations
  * Flexible way to build transformations
  * Matrix inverse
-----

= Planned =
The following features are planned but not yet implemented:
  * Support for double vectors and matrices
  * Compiler plugin!

= Feedback =

Any feedback regarding code correctness and optimization is welcomed. However keep in mind that the aim of the library is to stay as close to GLSL as possible, things that are astray from this path are unlikely to be implemented.