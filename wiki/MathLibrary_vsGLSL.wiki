#summary Differences with GLSL
#labels User-Guide

[MathLibrary#Guide Index]

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are other minor differences.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || Mat2x2 ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Swizzling ==
`xyzw`, `rgba`, and `stpq` swilling is supported for all vector types. Chain swizzling (eg: `v.wyxz.yx`) is supported for read operations but not supported for write operations (eg: `v.wyxz.yx = u` will not compile).

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
//defining a constant using declared type
var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4

//defining constant using a factory
val u = ConstVec3(1, 2, 3)
}}}

Using constants:
{{{
var mutable: Vec3 = Vec3(1)
var constant = ConstVec3(2, 2, 2)

//implicit conversion from const to mutable
mutable = constant
//copy without reassigning
mutable := constant

//implicit conversion from mutable to const
constant = mutable

val finalConstant = ConstVec3(1, 1, 1)
finalConstant = mutable //compile time error, since val cannot be reassigned
}}}

When writing functions, you can support both constant and mutable types without implicit conversions. To accomplish this, use the common supertype AnyVec:
{{{
//This function will trigger an implicit conversion if v is ConstVec3.
def foo(v: Vec3) = 2*v

//This function will accept both ConstVec3 and Vec3 without implicit conversions
def foo(v: AnyVec3) = 2*v

//Similar for matrices:
def bar(m: AnyMat3) :Mat3 = m*Mat3(2)
}}}

== Matrix constructors ==

Unlike GLSL, matrix constructors do not accept an arbitrary mix of floats and vectors. You can specify all the values or all the columns to construct a matrix.
Example:
{{{
val m = Mat2(1, 2, 3, 4)
val n = Mat3(Vec3.UnitX, Vec3.UnitY, Vec3.UnitZ)

// similar to GLSL
val s = Mat4(2) // a 4x4 matrix with 2 on diagonal
val t = Mat3(s) // a 3x3 matrix, equal to upper left 3x3 sub-matrix of s
}}}

== Matrix as multidimensional array ==

Writing into matrix using array notation is different from GLSL. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Modifying matrix columns ==

Writing with swizzling does not work for matrix accessors. Instead you can modify the upper part of the matrix while leaving the lower part intact by assigning smaller vectors as columns.

{{{
val m = Mat4(1)

m(0).xyzw = Vec4(4) //compile time error
m(1).xyz = Vec3(3) //compile time error
m(2).xy = Vec2(2) //compile time error

m(0) = Vec4(4) //works: coordinates xyzw of column 0 are modified
m(1) = Vec3(3) //works: coordinates xyz of column 1 are modified
m(2) = Vec2(2) //works: coordinates xy of column 2 are modified
}}}

== Modf ==
`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

== Operators ==
  * Prefix ++ and -- as well as postfix ++ and -- are not implemented to be consistent with Scala.
  * >>> and >>>= operators are added to integer vectors to compensate for the lack of unsigned types.

----

= Additions not present in GLSL =

Below is a quick reference of functions included into the MathLibrary that are not present in GLSL.

== Casting ==

Scala native casting `asInstanceOf[Type]` looks somewhat odd in math code. To make the code more readable it is recommended to use these casts:
  * bool(x)
  * byte(x)
  * short(x)
  * int(x)
  * long(x)
  * float(x)
  * double(x)

Examples:
{{{
val a = float(java.lang.Math.PI) //this is just an example, the constant Pi is defined in FloatMath
val b = int(sin(Pi/2)*100)
}}}

== Transformations ==

Mat2x3 and Mat3x4 are extended to act as 2d and 3d transformations. Additionally there is a special syntax to quickly construct arbitrary transformations. The order of applied operations is from left to right, so the the leftmost transformation happens first.

Examples:
{{{
// First rotate by 10 degrees, then translate then scale:
val t = Mat2x3 rotate(radians(10)) translate(Vec2(30, 10)) scale(4) // t is Mat2x3

t = t translate(Vec2(-10, 20)) rotate(radians(-40))
val p = t.transformPoint(point) // equivalent to t*Vec3(point, 1)
val v = t.transformVector(vector) // equivalent to t*Vec3(vector, 0)

// Alternative way to quickly build a transformation matrix,
// the order of operations is the same as the order of arguments:
val r = transformation(scale, rotation, translation) // r is Mat2x3

// When transforming points or vectors, t will be applied first, then r:
val combined = t concatenate(r) // combined is Mat2x3 equivalent to r*t
val c = combined.transformPoint(point) // equivalent to r*t*Vec3(point, 1)
}}}

== Other additions ==

  * `:=` operator, equivalent to set(), but does not require parentheses
  * `lengthSquare` method if you want to avoid using square root
  * `approxEqual` to compare floating point numbers, vectors and matrices
  * `hasErrors` method to quickly check if your vector or matrix has any NaN or Inf values
  * Quaternions
  * Functions for quaternion, matrix, and angle/axis rotation
  * `lerp` for matrices and `slerp` for quaternions
  * Functions to create projection matrices

[MathLibrary#Guide Back to Index]