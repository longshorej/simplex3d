#summary Differences with GLSL
#labels User-Guide

[MathLibrary#Guide Index]

= Differences with GLSL =

Aside from obvious differences, such as Scala variable declaration and function signatures, there are other minor differences.

== Type declarations ==

To stay consistent with Scala object naming conversions, the type names are distinct from GLSL.

Vectors examples:
|| *GLSL* || *Simplex3d* ||
|| vec2 || Vec2 ||
|| ivec2 || Vec2i ||
|| bvec2 || Vec2b ||

Matrix examples:
|| *GLSL* || *Simplex3d* ||
|| mat2 || Mat2 ||
|| mat2x2 || Mat2x2 ||
|| mat2x3 || Mat2x3 ||

If desired, you can change type declarations to be exactly the same as in GLSL using Scala imports. For example:
{{{
import simplex3d.math.{Vec3 => vec3, Vec3i => ivec3, Vec3b => bvec3}
}}}

== Unsigned types ==
Unsigned types `uint`, `uvec2`, `uvec3`, and `uvec4` are not present to be consistent with Scala.

== Swizzling ==
`xyzw`, `rgba`, and `stpq` swilling is supported for all vector types. Chain swizzling (eg: `v.wyxz.yx`) is supported for read operations but not supported for write operations (eg: `v.wyxz.yx = u` will not compile).

== Constants ==

Instead of `const` modifier there is a corresponding immutable object for each type. The Const classes are final and their accessors are read-only, so you have a compile time guarantee that the values will stay unchanged. Examples:
{{{
//defining a constant using declared type
var v: ConstVec4 = Vec4(1) //implicit conversion from Vec4 to ConstVec4

//defining constant using a factory
val u = ConstVec3(1, 2, 3)
}}}

Using constants:
{{{
var mutable: Vec3 = Vec3(1)
var constant = ConstVec3(2, 2, 2)

//implicit conversion from const to mutable
mutable = constant
//copy without reassigning
mutable := constant

//implicit conversion from mutable to const
constant = mutable

val finalConstant = ConstVec3(1, 1, 1)
finalConstant = mutable //compile time error, since val cannot be reassigned
}}}

== Matrix constructors ==

Unlike GLSL, matrix constructors do not accept an arbitrary mix of floats and vectors. You can specify all the values or all the columns to construct a matrix.
Example:
{{{
val m = Mat2(1, 2, 3, 4)
val n = Mat3(Vec3.UnitX, Vec3.UnitY, Vec3.UnitZ)

// similar to GLSL
val s = Mat4(2) // a 4x4 matrix with 2 on diagonal
val t = Mat3(s) // a 3x3 matrix, equal to upper left 3x3 sub-matrix of s
}}}

== Matrix as multidimensional array ==

Writing into matrix using array notation is different from GLSL. Example:
{{{
val m = Mat3(1)
m(0)(0) = 2 //compile time error
m(0, 0) = 2 //works
}}}

== Modifying matrix columns ==

Writing with swizzling does not work for matrix accessors. Instead you can modify the upper part of the matrix while leaving the lower part intact by assigning smaller vectors as columns.

{{{
val m = Mat4(1)

m(0).xyzw = Vec4(4) //compile time error
m(1).xyz = Vec3(3) //compile time error
m(2).xy = Vec2(2) //compile time error

m(0) = Vec4(4) //works: coordinates xyzw of column 0 are modified
m(1) = Vec3(3) //works: coordinates xyz of column 1 are modified
m(2) = Vec2(2) //works: coordinates xy of column 2 are modified
}}}

== Modf ==

`modf(x: float, i: *float)` is missing because of the lack of pointers in the language. The vector versions of modf are present.

== Operators ==

  * Prefix ++ and -- as well as postfix ++ and -- are not implemented to be consistent with Scala.
  * >>> and >>>= operators are added to integer vectors to compensate for the lack of unsigned types.

== Functions ==

`in` and `out` attributes are supported via type aliasing. For example, GLSL `in vec3` becomes `inVec3`.

`in/out` mappring to prefixes:
|| *GLSL attribute* || *Simplex3d type prefix* ||
|| default (no attribute) || in ||
|| in || in ||
|| out || out ||
|| inout || out ||

It is important to remember that GLSL default (no attribute) maps to `in` prefix in simplex3d. There are subtle but important differences with the way default (no prefix) arguments are handled. If you do not specify the prefix, then the argument can be either `in` or `out` depending on the circumstances. To understand how it works, consider the following table:

|| *GLSL* || *Simplex3d* || *Can trigger implicit conversions* || *Are argument changes persistent after the function call?* ||
|| vec3 || inVec3 || from Vec3i to Vec3 || cannot modify the argument ||
|| in vec3 || inVec3 || from Vec3i to Vec3 || cannot modify the argument ||
|| out vec3 || outVec3 || none || modifications are persistent after the function call ||
|| inout vec3 || outVec3 || none || modifications are persistent after the function call ||
|| _not supported_ || Vec3 || from Vec3i to Vec3, from ConstVec3(i) to Vec3 || persistent *if the argument was not converted* ||

Examples explaining the use of `in` prefix:
{{{
// This function will trigger an implicit conversion if v is ConstVec3.
def foo(v: Vec3) = 2*v

// This function will accept both ConstVec3 and Vec3 without implicit conversions
def foo(v: inVec3) = 2*v

// Similar for matrices:
def bar(m: inMat3) :Mat3 = m*Mat3(2)
}}}

To understand why it is important to use the prefix `out` consider the following example:
{{{
def foo(v: Vec3) { v *= 2 }
val i = Vec3i(1)
foo(i) // i is converted to Vec3 and the new instance is passed to foo,
       // the new instance is modified and the changes are lost.
println(i) // prints "Vec3i(1, 1, 1)"
}}}

To prevent this behaviour use the `out` prefix:
{{{
def foo(v: outVec3) { v *= 2 }
val i = Vec3i(1)
foo(i) // compile time error
}}}

The prefixes `in` and `out` are optional and you can get the desired functionality without using them. However it is recommended to always use the prefixes. This will clearly state your intentions and help you to avoid bugs.

----

= Additions to GLSL =

Below is a quick reference of functions and constructs included into the MathLibrary that are not present in GLSL.

== Casting ==

Scala native casting `asInstanceOf[Type]` looks somewhat odd in math code. To make the code more readable it is recommended to use these casts:
  * bool(x)
  * byte(x) // not in GLSL
  * short(x) // not in GLSL
  * int(x)
  * long(x) // not in GLSL
  * float(x)
  * double(x) // not in GLSL

Examples:
{{{
val a = byte(log(2))
val b = int(sin(Pi/2)*100)
}}}

== Transformations ==

Mat2x3 and Mat3x4 are extended to act as 2d and 3d transformations. Additionally there is a special syntax to quickly construct arbitrary transformations. The order of applied operations is from left to right, so the the leftmost operation happens first.

To make a new transformation, start by writing the matrix type followed by the desired sequence of transformation operations:
{{{
val t0 = Mat3x4 rotateX(radians(10)) translate(Vec3(0, 1, 0))
//       ^ equivalent to using a constant Mat3x4.Identity (but more efficient)
}}}

To append operations to an existing transformation, start by writing a variable name of the existing transformation:
{{{
val t1 = t0 scale(2) rotateY(radians(30))
}}}

The 2-d transformation operations are:
  * scale(vec2)
  * scale(scalar)
  * rotate(radians)
  * translate(vec2)
  * concatenate(mat2x2), concatenates a combination of rotation/scale
  * concatenate(mat2x3), concatenates a transformation

The 3-d transformation operations are:
  * scale(vec3)
  * scale(scalar)
  * rotate(quaternions)
  * rotate(radians, axis)
  * rotateX(radians)
  * rotateY(radians)
  * rotateZ(radians)
  * translate(vec3)
  * concatenate(mat3x3), concatenates a combination of rotation/scale
  * concatenate(mat3x4), concatenates a transformation

Additionally 2x3 and 3x4 matrices have special methods to transform points and vectors:
{{{
{
  val u = Vec2(1)
  val t = Mat2x3(1)
  val p = t.transformPoint(u) // equivalent to t*Vec3(u, 1)
  val v = t.transformVector(u) // equivalent to t*Vec3(u, 0)
}

{
  val u = Vec3(1)
  val t = Mat3x4(1)
  val p = t.transformPoint(u) // equivalent to t*Vec4(u, 1)
  val v = t.transformVector(u) // equivalent to t*Vec4(u, 0)
}
}}}

Examples:
{{{
// First rotate by 10 degrees, then translate then scale:
var t = Mat2x3 rotate(radians(10)) translate(Vec2(30, 10)) scale(4) // t is Mat2x3

t = t translate(Vec2(-10, 20)) rotate(radians(-40))
val p = t.transformPoint(point) // equivalent to t*Vec3(point, 1)
val v = t.transformVector(vector) // equivalent to t*Vec3(vector, 0)

// Alternative way to quickly build a transformation matrix,
// the order of operations is the same as the order of arguments:
val r = transformation(scale, rotation, translation) // r is Mat2x3

// When transforming points or vectors, t will be applied first, then r:
val combined = t concatenate(r) // combined is Mat2x3 equivalent to r*t
val c = combined.transformPoint(point) // equivalent to r*t*Vec3(point, 1)
}}}

== Other additions ==

  * Quaternions.
  * `:=` operator, equivalent to set(), but does not require parentheses.
  * `approxEqual` to compare floating point numbers, vectors and matrices.
  * `hasErrors` method to quickly check if your vector or matrix has any NaN or Inf values.
  * Functions for quaternion, matrix, and angle/axis rotation.
  * `lerp` for matrices and `slerp` for quaternions.
  * Functions to create projection matrices.

[MathLibrary#Guide Back to Index]