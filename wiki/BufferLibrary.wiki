#summary Main reference page for BufferLibrary
#labels User-Guide

= Features =

  * *Designed to integrate seemelessly with mathlib.*
  * *Simple and convinient API.*
  * *On-the-fly primitive type conversion.*
  * *Flexible typing system.*
  * *Read-only buffer types.*
  * *Support for arrays, direct buffers, and interleaved buffers.*
  * *Minimal overhead. Specialization for primitive types.*
  * *Maximum performance on bulk copy and bulk conversion.*
  * *Integrated with scala.collection.*
  * *Easy to integrate with OpenGL.*


= Snippets =

*Mathlib integration:*
{{{
    // vertices, a vertex buffer.
    // normals, a normal buffer.
    // lines, result buffer to store lines.

    var i = 0; while (i < vertices.size) {
      val vertex = vertices(i) // reading Vec3
      
      lines(i*2) = vertex // writing Vec3
      lines(i*2 + 1) = vertex + normals(i) // combining math operations and writing

      i += 1
    }
}}}

*Making new sequences:*
{{{
    // size, sequence size.
    // array, float array with some data.
    
    // Making an empty sequence backed by a direct buffer:
    val normals = DataBuffer[Vec3, RawFloat](size)
    
    // Wrapping an existing array:
    val vertices = DataArray[Vec3, RawFloat](array)

    // Making a new data array from a list of values:
    val points = DataArray[Vec3, RawFloat](
      Vec3(0, 0, 0),
      Vec3(0, 1, 0),
      Vec3(1, 1, 0),
      Vec3(1, 0, 0)
    )
}}}

*On the fly conversion:*
{{{
    // Making a sequence backed by an array of normalized unsigned bytes.
    val color = DataArray[Vec4, NUByte](10)

    var i = 0; while (i < color.size) {
      // Color buffer will contain red gradient.
      val red = float(i + 1)/color.size

      // A float vector representing an RGBA color is stored
      // as 4 bytes which contain RGBA components, one per byte.
      color(i) = Vec4(red, 0, 0, 1)

      i += 1
    }
}}}

*Typing system:*
{{{
    // Data must be backed by a normalized array (always in range [0, 1]).
    def function1(data: DataArray[Vec3, _ <: Normalized]) {}
    
    // Data must be backed by an array of unsigned values (always positive).
    def function2(data: DataArray[Vec3, _ <: Unsigned]) {}
    
    // Data must be backed by an array of shorts, either signed or unsigned.
    def function3(data: DataArray[Vec3, _ <: RawShort]) {}
    
    // Data must be backed by an array of half-floats or floats.
    def function4(data: DataArray[Vec3, _ <: Fractional]) {}
    
    // Data must be backed by an array of values that can be converted to floats.
    def function5(data: DataArray[Vec3, _ <: ReadableFloat]) {}
}}}

*Read-only buffers:*
{{{
    // A sample buffer.
    val vertices = DataBuffer[Vec3, RawFloat](100)
    
    // ReadOnly indicates that the function is only interested in reading the data.
    def fun(data: ReadOnlyDataBuffer[Vec3, _ <: ReadableFloat]) {}

    // Read-write sequence can pass as read-only sequence.
    fun(vertices)

    // An enforced read-only sequence.
    val enforced = vertices.asReadOnly()
    // Any attempt to write into an enforced read-only sequence will result in an exception.
    enforced.asInstanceOf[DataBuffer[Vec3, RawFloat]](0) = Vec3(0)
}}}

*Aarrays, direct buffers, and interleaved buffers:*
{{{
    // A sequence backed by an array:
    val normals = DataArray[Vec3, RawFloat](100)

    // A sequence backed by a direct buffer:
    val vertices = DataBuffer[Vec3, RawFloat](100)

    // iVertex and iNormal are interleaved and share the same buffer:
    val (iVertices, iNormals) = interleave(vertices, normals)(vertices.size)

    // Making empty interleaved sequences:
    val (emptyVertices, emptyNormals) = interleave(
      DataSeq[Vec3, RawFloat], DataSeq[Vec3, RawFloat]
    )(100)
}}}

*Specialization for primitive types:*
{{{
    // A sequence of ints, backed by an array of shorts.
    val data = DataArray[Int1, SShort](1000)

    var i = 0; while (i < data.size) {
      // No boxing/unboxing takes place:
      data(i) = i
    }
}}}

*Bulk copy and bulk conversion:*
{{{
    // vertices, a vertex buffer.

    val copying = DataArray[Vec3, RawFloat](vertices.size)
    // The same performance as System.arraycopy().
    copying.put(vertices)
    
    val converting = DataArray[Vec3, HalfFloat](vertices.size)
    // Converts components directly, does not create new objects.
    converting.put(vertices)
}}}

*Integration with scala.collection:*
{{{
    // vertices, a vertex buffer.

    // A sample transformation.
    val t = Mat3x4 scale(2) rotateX(radians(30)) translate(Vec3(4, 0, 1))

    // Checks if vertices have nan or inf values using forall()
    if (vertices.forall(!hasErrors(_))) {
      println("No abnormal floating point values found.")
    }
    
    // transformed is IndexedSeq[Vec3]
    val transformed =
      // Iterating using scala for-comprehension:
      for (vertex <- vertices) yield { 
        t.transformPoint(vertex)
      }
    
    // copying IndexedSeq[Vec3] into DataSeq[Vec3, _]
    vertices.put(transformed)
}}}

*Integration with OpenGL:*
{{{
    // vertices, a vertex buffer.

    // Sending buffer data with JOGL:
    gl.glBufferData(
      GL_ARRAY_BUFFER, vertices.byteSize,
      vertices.bindingBuffer(0), GL_DYNAMIC_DRAW
    )

    // Defining a vertex pointer with JOGL:
    gl.glverticesPointer(
      vertices.components, vertices.bindingType,
      vertices.byteStride, vertices.byteOffset
    )
}}}

= Example =

{{{
import simplex3d.math._
import simplex3d.math.floatm._
import simplex3d.math.floatm.FloatMath._

import simplex3d.buffer._
import simplex3d.buffer.floatm._


object BufferExample {

  def main(args: Array[String]) {
    val size = 10

    // read as Vec3f, the backing store is an array of half floats
    val vertex = DataArray[Vec3f, HalfFloat](size)

    // read as Vec3f, the backing store is an array of normalized signed shorts
    val normal = DataArray[Vec3f, NSShort](size)

    // read as Vec4f, the backing store is an array of normalized unsigned bytes
    val color = DataArray[Vec4f, NUByte](size)


    // fill our arrays with some random data
    val random = new java.util.Random(1)
    def r = random.nextFloat
    for (i <- 0 until size) {
      vertex(i) = Vec3f(r, r, r)*10
      normal(i) = normalize(Vec3f(r, r, r))
      color(i) = Vec4f(r, r, r, r)
    }

    // interleave the arrays into one buffer
    val (
      interleavedVertex,
      interleavedNormal,
      interleavedColor,
      interleavedTexture // this sequence is empty
    ) = interleave(
      vertex,
      normal,
      color,
      DataSeq[Vec2f, RawFloat] // a placeholder to generate an empty sequence
    )(vertex.size)
  }
}
}}}