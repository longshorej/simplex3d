#summary Main reference page for BufferLibrary

= Features =

  * *Designed to integrate seemelessly with mathlib.*
  * *Simple and convinient API.*
  * *On-the-fly primitive type conversion.*
  * *Flexible typing system.*
  * *Read-only buffer types.*
  * *Support for arrays, direct buffers, and interleaved buffers.*
  * *Minimal overhead. Specialization for primitive types.*
  * *Maximum performance on bulk copy and bulk conversion.*
  * *Integrated with scala.collection.*
  * *Easy to integrate with opengl.*


= Snippets =

Iterating over sequences and Mathlib integration:
{{{
    // vertices, a vertex buffer.
    // normals, a normal buffer.
    // lines, result buffer to store lines.

    var i = 0; while (i < vertices.size) {
      val vertex = vertices(i) // reading Vec3
      
      lines(i*2) = vertex // writing Vec3
      lines(i*2 + 1) = vertex + normals(i) // combining math operations and writing

      i += 1
    }
}}}

Making new sequences:
{{{
    // size, sequence size.
    // array, float array with some data.
    
    // Making an empty sequence backed by a direct buffer:
    val normals = DataBuffer[Vec3, RawFloat](size)
    
    // Wrapping an existing array:
    val vertices = DataArray[Vec3, RawFloat](array)
}}}

Indices:
{{{
// TODO
}}}


= Example =

{{{
import simplex3d.math._
import simplex3d.math.floatm._
import simplex3d.math.floatm.FloatMath._

import simplex3d.buffer._
import simplex3d.buffer.floatm._


object BufferExample {

  def main(args: Array[String]) {
    val size = 10

    // read as Vec3f, the backing store is an array of half floats
    val vertex = DataArray[Vec3f, HalfFloat](size)

    // read as Vec3f, the backing store is an array of normalized signed shorts
    val normal = DataArray[Vec3f, NSShort](size)

    // read as Vec4f, the backing store is an array of normalized unsigned bytes
    val color = DataArray[Vec4f, NUByte](size)


    // fill our arrays with some random data
    val random = new java.util.Random(1)
    def r = random.nextFloat
    for (i <- 0 until size) {
      vertex(i) = Vec3f(r, r, r)*(r*10)
      normal(i) = normalize(Vec3f(r, r, r))
      color(i) = Vec4f(r, r, r, r)
    }

    // interleave the arrays into one buffer
    val (
      interleavedVertex,
      interleavedNormal,
      interleavedColor,
      interleavedTexture // this sequence is empty
    ) = interleave(
      vertex,
      normal,
      color,
      DataSeq[Vec2f, RawFloat] // a placeholder to generate an empty sequence
    )(vertex.size)

    // check for shared content
    println("shared: " + vertex.sharesContent(normal))
    println("sharedInterleaved: " + interleavedVertex.sharesContent(interleavedNormal))
  }
}
}}}