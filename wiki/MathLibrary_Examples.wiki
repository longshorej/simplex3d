#summary Some examples on how to use the MathLibrary

The following is a list of examples on how to use the API:
{{{
import simplex3d.math.floatm.renamed._ //using short names for Float data types
import simplex3d.math.floatm.FloatMath._ //using all float functions

//Factories
var u = Vec2(1)
var v = Vec4(1, 2, 3, 4)
v = Vec4(u, 5, 6)

val m = Mat4x3(1)
val n = Mat4(v, v, v, v)

//Accessors
v.x = 10
v.z = u.x

m(0) = v
m(0, 3) = 4

//Swizzling
val a = v.xyz
val b = v.wxz
val c = v.rb

v.xz = Vec2(0)
v.ra = v.wy

//Arithmetic operations on vectors
val s = v.xyz + Vec3(1, 2, 3)
s *= 10
val t = 0.5f*(s + v)

//Matrix multiplication
val m = Mat4(2)
val n = Mat4x3(col0, col1, col2)
val t = m*n //t: Mat4x3

// Basic operations on vectors
val len = length(v)
val dist = distance(u, v)
val d = dot(u, v)
val normal = normalize(v)

// Component-wise operations on vectors
val inrads = radians(v)
val indegrees = degrees(inrads)
val allsin = sin(v)
val angles = asin(allsin)
var res = sinh(v)
res = asinh(v)
val p = pow(u, v) //p.x = u.x^v.x; p.y = u.y^v.y
val allexp = exp(v)
val back = log(allexp)
res = exp2(v)
res = log2(v)
val root = sqrt(v)
val invroot = inversesqrt(v) // 1/sqrt
val allabs = abs(v)
val signs = sign(v)
res = floor(v)
res = trunc(v)
res = round(v)
res = ceil(v)
res = fract(v)
val allmin = min(u, v)
val c = clamp(v, minVal, maxVal)

//Noise functions backed by simplex noise implementation
val n1 = noise1(v) //n1: Float
val n2 = noise2(v) //n2: Vec2
val n3 = noise3(v) //n3: Vec3
val n4 = noise4(v) //n4: Vec4

//`approxEqual` to compare floating point numbers, vectors and matrices
if (approxEqual(u, v, 0.0001f)) println("approx")

//Quaternions and angle/axis rotations
val q1 = quatFrom(radians(30), Vec3.UnitX)
val q2 = quatFrom(radians(45), Vec3.UnitY)
val q = q2*q1 // first rotaty by q1 then by q2
val v = q*Vec3(1, 1, 1) //rotate Vec3(1, 1, 1) by q

val r1 = rotationMatFrom(q)
val r2 = rotationMatFrom(radians(180), normalize(Vec3(1, 1, 1))

val result = Vec3(0)
val angle1 = angleAxisFrom(r1, result); val axis1 = Vec3(result)
val angle2 = angleAxisFrom(q2, result); val axis2 = Vec3(result)

//`lerp` for matrices and `slerp` for quaternions
val interpolatedMat = lerp(m0, m1, 0.4f)
val q3 = slerp(q1, q2, 0.8f)

//Projection matrices for setting 3d camera
val camPerspective = perspective(fieldOfView, aspectRatio, near, far)
val camOrtho = ortho(left, right, bottom, top, near, far)

//2x3 and 3x4 matrices as transformations
val tf = Mat3x4(1)
val position = tf.transofrmPoint(v)
val orientation = tf.transofrmVector(u)

//Flexible way to build transformations
// Template: Transform(translation, rotation, scale)
// Template: Transform(translation, rotation)
// Template: Transform(rotation, scale)
// InverseTransform avoids matrix inverse, same templates as Transform
val model = Transform(Vec3(0, 1, 0), radians(60), Vec3.UnitY, 2) //model: Mat3x4
val view = InverseTransform(cam.translation, cam.rotation, cam.scale) //view: Mat3x4
val modelView = view*model // modelView: Mat3x4

val complicated = Translation(u)*Scale(s1)*Rotation(q1)*Scale(s2)*Translation(v)
// first p is translated by v, then scaled by s2, then rotated by q1,
// then scaled by s1 and finally translated by u
val p = complicated.transformPoint(point)

//Matrix inverse
val inv = inverse(transformationMatrix)
}}}