#summary Performance and fine tuning.
#labels Phase-Implementation,Phase-Deploy,User-Guide

[MathLibrary#Guide Index]

= Fine Tuning JVM Options =

The library relies on JVM to optimise the code for performance. It is highly recommended to enable `-XX:+DoEscapeAnalysis` option on Java6u14 or later versions. This option is enabled by default on recent Java 7 builds.
Escape analysis will make the code written with math library run much faster.

In conjunction with `-XX:+DoEscapeAnalysis`, you can experiment with `-XX:+AggressiveOpts` and `-XX:+UseCompressedOops` options for additional minor performance boost.


= Fine Tuning Garbage Collection =

Modern JVMs can easily handle short-lived garbage objects. However continious supply of long-lived garbage can cause Garbage Collections to occur less often and take longer to finish. This may cause noticable jittering in animation. To prevent this, you should avoid leaking references produced by computation results into permanent objects.

The general guideline is to use mutable vals on permanent objects. For example:
{{{
class Model {
  // all vals
  val translation = Vec3(0)
  val rotation = Quat4(1, 0, 0, 0)

  ...

  def update(time: Float) {
    // updated using :=
    translation := translation + speed*time
    rotation := Quat4 rotateX(radians(time*degreesPerSecond))
  }
}
}}}

Note the use of := operator to set the new value instead of reassigning the reference.

Sharing a mutable object could cause unexpected behaviour when the value of the shared object is updated by one of the owners. Using mutable vals and updating with := can also prevent this problem.

When using := operator with Java 7 or another JVM with Escape Analysis, there is an additional benefit. Consider the following code:
{{{
  val translation = Vec3(0)
  def update() {
    translation := translation + speed*time
  }
}}}
When optimised with Escape Analysis the function is inlined in a way that bypasses creation of any new objects and the resulting values are assigned directly into the "translation" property.
Now consider this code:
{{{
  var translation = Vec3(0)
  def update() {
    translation = translation + speed*time
  }
}}}
Escape Analysis cannot eliminate the creation of a new object that is then assigned to the "translation" variable. This results in a slower code.
Moreover, and this is true for both Java 6 and Java 7, when "translation" is reassigned each frame, the old value becomes long-lived garbage. Having many methods producing long-live garbage like this may cause longer GC pauses which results in noticable animation jittering on the screen.


== Compiler plugin ==

An optional compiler plugin to inline vector math may be implemented some time after 2.8.0.final release.

Escape analysis seems to eliminate temporary new objects in the critical sections of the code, giving results that are very close to the results with temporary variable management the compiler plugin can do. JVM can optimise code at a lower level and managing temporary valiriables manually or via compiler plugin can interfere with that process causing the code to perform slower in some cases.
It does not seem to be feasible to manage temporary variables via a compiler plugin. On the other hand inlining vector math can increase performance and may be implemented in the future as an optional compiler plugin.


[MathLibrary#Guide Back to Index]